

from app.classes.data_loader.bulk_data_loader import BulkDataLoader
from app.tools.myTools import FromTimestampToDateTime
from app.classes.repository.obsMeteor import QA

class DlCsv(BulkDataLoader):
    def __init__(self):
        super().__init__()

    def getObsDateTime(self, row2, col_mapping, cur_poste):
        ..
        return date_obs_utc, date_obs_local

    def getConvertKey(self):
        return 'mfr_csv'


    def getColMapping(self, data_iterator):
        col_mapping = {'date_utc': 0, 'usUnits': 1, 'interval': 2, 'outTemp': 3, 'outHumidity': 4, 'windSpeed': 5, 'windDir': 6, 'rain': 7, 'pressure': 8, 'radiation': 9, 'dewpoint': 10, 'windGust': 11, 'windGustDir': 12, 'windGustTime': 13, 'windGustDirTime': 14, 'windGustTime': 15, 'windGustDirTime': 16}
        return col_mapping

    def isMesureQualified(self, a_measure):
        return True

    def getValues(self, cur_row, col_mapping, a_mesure):
        # return cur_val, cur_qa_val, interval
        pass

    def getMinMaxValues(self, cur_poste, fields_array, col_mapping, a_mesure, cur_val, obs_date_local):
        cur_min = cur_min_qa = cur_min_time = is_min_in_obs = None
        cur_max = cur_max_qa = cur_max_date = is_max_in_obs = cur_max_dir = None

        if a_mesure['min'] is True:
            cur_min = float(cur_val)
            cur_min_qa = QA.UNSET.value
            cur_min_time = obs_date_local
            cur_min_field = a_mesure['csv_minmax'].get("min")
            cur_min_field_qa = a_mesure['csv_minmax'].get("qmin")
            cur_min_time_field = a_mesure['csv_minmax'].get("minTime")
            is_min_in_obs = True

            if cur_min_field is not None and cur_min_field != '':
                tmp_min = fields_array[cur_min_field]
                if tmp_min != '' and tmp_min is not None:
                    cur_min = float(tmp_min)
                    is_min_in_obs = False
                if cur_min_field_qa is not None and cur_min_field_qa != '':
                    cur_min_qa = self.transcodeQAMeteoFrance(fields_array[cur_min_field_qa])

            if cur_min_time_field is not None and cur_min_time_field != '':
                tmp_min_time = fields_array[cur_min_time_field]
                if tmp_min_time != '' and tmp_min_time is not None:
                    cur_min_time = self.adjustTime(cur_poste, obs_date_local, tmp_min_time)
                    is_min_in_obs = False

        if a_mesure['max'] is True:
            cur_max = float(cur_val)
            cur_max_qa = QA.UNSET.value
            cur_max_dir = None
            cur_max_time = obs_date_local
            cur_max_field = a_mesure['csv_minmax'].get("max")
            cur_max_field_qa = a_mesure['csv_minmax'].get("qmax")
            cur_max_time_field = a_mesure['csv_minmax'].get("maxTime")
            cur_max_dir_field = a_mesure['csv_minmax'].get("maxDir")
            is_max_in_obs = True

            if cur_max_field is not None and cur_max_field != '':
                tmp_max = fields_array[cur_max_field]
                if tmp_max != '' and tmp_max is not None:
                    cur_max = float(tmp_max)
                    is_max_in_obs = False
                if cur_max_field_qa is not None and cur_max_field_qa != '':
                    cur_max_qa = self.transcodeQAMeteoFrance(fields_array[cur_max_field_qa])

            if cur_max_time_field is not None and cur_max_time_field != '':
                tmp_max_time = fields_array[cur_max_time_field]
                if tmp_max_time != '' and tmp_max_time is not None:
                    cur_max_time = self.adjustTime(cur_poste, obs_date_local, tmp_max_time)
                    is_max_in_obs = False

            cur_max_dir = fields_array[cur_max_dir_field] if cur_max_dir is not None else None

        return cur_min, cur_min_qa, cur_min_time, is_min_in_obs, cur_max, cur_max_qa, cur_max_time, cur_max_qa, is_max_in_obs, cur_max_dir

    def getNextRow(self, data_iterator):
        next_row = data_iterator.fetchone()
        if next_row is None:
            data_iterator.close()
        return next_row

    def fixMinMax(self, str_mesure_list, cur_poste, x_max_min_date, x_min_min_date):
        return ["delete from x_max where obs_id is not null and mesure_id in " + str_mesure_list +
                " and poste_id = " + str(cur_poste.data.id) + " and date_local in " +
                " (select date_local from x_max where obs_id is null and date_local >= '" +
                x_max_min_date.strftime("%Y/%m/%d, %H:%M:%S") + "' and mesure_id in " + str_mesure_list +
                " and poste_id = " + str(cur_poste.data.id) + ")",
                "delete from x_min where obs_id is not null and mesure_id in " + str_mesure_list +
                " and poste_id = " + str(cur_poste.data.id) + " and date_local in " +
                " (select date_local from x_min where obs_id is null and date_local >= '" +
                x_min_min_date.strftime("%Y/%m/%d, %H:%M:%S") + "' and mesure_id in " + str_mesure_list +
                " and poste_id = " + str(cur_poste.data.id) + ")"
                ]


    def transcodeQACode(self, qa_meteoFR):
        if qa_meteoFR is None or qa_meteoFR == 0:
            return QA.UNSET.value
        if qa_meteoFR == 2:
            return QA.UNVALIDATED.value
        return QA.VALIDATED.value
